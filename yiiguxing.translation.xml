<application>
  <component name="AppStorage">
    <histories>
      <item value="北向接口" />
      <item value="platform" />
      <item value="参数帧" />
      <item value="上电复位" />
      <item value="    &#10;      Compares two Dates for ordering.&#10;     &#10;      @param   anotherDate   the &lt;code&gt;Date&lt;code&gt; to be compared.&#10;      @return  the value &lt;code&gt;0&lt;code&gt; if the argument Date is equal to&#10;               this Date; a value less than &lt;code&gt;0&lt;code&gt; if this Date&#10;               is before the Date argument; and a value greater than&#10;           &lt;code&gt;0&lt;code&gt; if this Date is after the Date argument.&#10;      @since   1.2&#10;      @exception NullPointerException if &lt;code&gt;anotherDate&lt;code&gt; is null.&#10;     " />
      <item value="正常" />
      <item value="安全运行天数" />
      <item value="present" />
      <item value="&#10;      Obtains a {@code Duration} representing the duration between two temporal objects.&#10;      &lt;p&gt;&#10;      This calculates the duration between two temporal objects. If the objects&#10;      are of different types, then the duration is calculated based on the type&#10;      of the first object. For example, if the first argument is a {@code LocalTime}&#10;      then the second argument is converted to a {@code LocalTime}.&#10;      &lt;p&gt;&#10;      The specified temporal objects must support the {@link ChronoUnitSECONDS SECONDS} unit.&#10;      For full accuracy, either the {@link ChronoUnitNANOS NANOS} unit or the&#10;      {@link ChronoFieldNANO_OF_SECOND NANO_OF_SECOND} field should be supported.&#10;      &lt;p&gt;&#10;      The result of this method can be a negative period if the end is before the start.&#10;      To guarantee to obtain a positive duration call {@link abs()} on the result.&#10;     &#10;      @param startInclusive  the start instant, inclusive, not null&#10;      @param endExclusive  the end instant, exclusive, not null&#10;      @return a {@code Duration}, not null&#10;      @throws DateTimeException if the seconds between the temporals cannot be obtained&#10;      @throws ArithmeticException if the calculation exceeds the capacity of {@code Duration}&#10;     " />
      <item value="小数" />
      <item value="&#10;      Returns the {@code float} value corresponding to a given&#10;      bit representation.&#10;      The argument is considered to be a representation of a&#10;      floating-point value according to the IEEE 754 floating-point&#10;      &quot;single format&quot; bit layout.&#10;     &#10;      &lt;p&gt;If the argument is {@code 0x7f800000}, the result is positive&#10;      infinity.&#10;     &#10;      &lt;p&gt;If the argument is {@code 0xff800000}, the result is negative&#10;      infinity.&#10;     &#10;      &lt;p&gt;If the argument is any value in the range&#10;      {@code 0x7f800001} through {@code 0x7fffffff} or in&#10;      the range {@code 0xff800001} through&#10;      {@code 0xffffffff}, the result is a NaN.  No IEEE 754&#10;      floating-point operation provided by Java can distinguish&#10;      between two NaN values of the same type with different bit&#10;      patterns.  Distinct values of NaN are only distinguishable by&#10;      use of the {@code Float.floatToRawIntBits} method.&#10;     &#10;      &lt;p&gt;In all other cases, let &lt;i&gt;s&lt;i&gt;, &lt;i&gt;e&lt;i&gt;, and &lt;i&gt;m&lt;i&gt; be three&#10;      values that can be computed from the argument:&#10;     &#10;      &lt;blockquote&gt;&lt;pre&gt;{@code&#10;      int s = ((bits &gt;&gt; 31) == 0) ? 1 : -1;&#10;      int e = ((bits &gt;&gt; 23) &amp; 0xff);&#10;      int m = (e == 0) ?&#10;                      (bits &amp; 0x7fffff) &lt;&lt; 1 :&#10;                      (bits &amp; 0x7fffff) | 0x800000;&#10;      }&lt;pre&gt;&lt;blockquote&gt;&#10;     &#10;      Then the floating-point result equals the value of the mathematical&#10;      expression &lt;i&gt;s&lt;i&gt;&amp;middot;&lt;i&gt;m&lt;i&gt;&amp;middot;2&lt;sup&gt;&lt;i&gt;e&lt;i&gt;-150&lt;sup&gt;.&#10;     &#10;      &lt;p&gt;Note that this method may not be able to return a&#10;      {@code float} NaN with exactly same bit pattern as the&#10;      {@code int} argument.  IEEE 754 distinguishes between two&#10;      kinds of NaNs, quiet NaNs and &lt;i&gt;signaling NaNs&lt;i&gt;.  The&#10;      differences between the two kinds of NaN are generally not&#10;      visible in Java.  Arithmetic operations on signaling NaNs turn&#10;      them into quiet NaNs with a different, but often similar, bit&#10;      pattern.  However, on some processors merely copying a&#10;      signaling NaN also performs that conversion.  In particular,&#10;      copying a signaling NaN to return it to the calling method may&#10;      perform this conversion.  So {@code intBitsToFloat} may&#10;      not be able to return a {@code float} with a signaling NaN&#10;      bit pattern.  Consequently, for some {@code int} values,&#10;      {@code floatToRawIntBits(intBitsToFloat(start))} may&#10;      &lt;i&gt;not&lt;i&gt; equal {@code start}.  Moreover, which&#10;      particular bit patterns represent signaling NaNs is platform&#10;      dependent; although all NaN bit patterns, quiet or signaling,&#10;      must be in the NaN range identified above.&#10;     &#10;      @param   bits   an integer.&#10;      @return  the {@code float} floating-point value with the same bit&#10;               pattern.&#10;     " />
      <item value="温补" />
      <item value="补偿" />
      <item value="保护" />
      <item value="Incorrect" />
      <item value="Case switching, sorting, filtering, incrementing, aligning to columns, grepping, escaping, encoding..." />
      <item value="Manage pull requests and conduct code reviews in your IDE with full source-tree context. Comment on any line, not just the diffs. Use jump-to-definition, your favorite keybindings, and code intelligence with more of your workflow." />
      <item value="Absent" />
      <item value="盘符" />
      <item value="duty" />
      <item value="占空比" />
      <item value="Found multiple occurrences of org.json.JSONObject on the class path:" />
      <item value="You may wish to exclude one of them to ensure predictable runtime behavior" />
      <item value="lightning arrester" />
      <item value="结构" />
      <item value="差值" />
      <item value="相差" />
      <item value="差" />
      <item value="injection" />
      <item value="检查" />
      <item value="检测" />
      <item value="透传" />
      <item value="profile" />
      <item value="清空" />
      <item value="maxFileSize property is mandatory." />
      <item value="灰色" />
      <item value="局部放电" />
      <item value="局放" />
      <item value="重复" />
      <item value="峰峰值" />
      <item value="有效值" />
      <item value="位移" />
      <item value="加速度" />
      <item value="振动" />
      <item value="数据类型" />
      <item value="数值" />
      <item value="单位" />
      <item value="/**&#10;     * Returns the {@code float} value corresponding to a given&#10;     * bit representation.&#10;     * The argument is considered to be a representation of a&#10;     * floating-point value according to the IEEE 754 floating-point&#10;     * &quot;single format&quot; bit layout.&#10;     *&#10;     * &lt;p&gt;If the argument is {@code 0x7f800000}, the result is positive&#10;     * infinity.&#10;     *&#10;     * &lt;p&gt;If the argument is {@code 0xff800000}, the result is negative&#10;     * infinity.&#10;     *&#10;     * &lt;p&gt;If the argument is any value in the range&#10;     * {@code 0x7f800001} through {@code 0x7fffffff} or in&#10;     * the range {@code 0xff800001} through&#10;     * {@code 0xffffffff}, the result is a NaN.  No IEEE 754&#10;     * floating-point operation provided by Java can distinguish&#10;     * between two NaN values of the same type with different bit&#10;     * patterns.  Distinct values of NaN are only distinguishable by&#10;     * use of the {@code Float.floatToRawIntBits} method.&#10;     *&#10;     * &lt;p&gt;In all other cases, let &lt;i&gt;s&lt;/i&gt;, &lt;i&gt;e&lt;/i&gt;, and &lt;i&gt;m&lt;/i&gt; be three&#10;     * values that can be computed from the argument:&#10;     *&#10;     * &lt;blockquote&gt;&lt;pre&gt;{@code&#10;     * int s = ((bits &gt;&gt; 31) == 0) ? 1 : -1;&#10;     * int e = ((bits &gt;&gt; 23) &amp; 0xff);&#10;     * int m = (e == 0) ?&#10;     *                 (bits &amp; 0x7fffff) &lt;&lt; 1 :&#10;     *                 (bits &amp; 0x7fffff) | 0x800000;&#10;     * }&lt;/pre&gt;&lt;/blockquote&gt;&#10;     *&#10;     * Then the floating-point result equals the value of the mathematical&#10;     * expression &lt;i&gt;s&lt;/i&gt;&amp;middot;&lt;i&gt;m&lt;/i&gt;&amp;middot;2&lt;sup&gt;&lt;i&gt;e&lt;/i&gt;-150&lt;/sup&gt;.&#10;     *&#10;     * &lt;p&gt;Note that this method may not be able to return a&#10;     * {@code float} NaN with exactly same bit pattern as the&#10;     * {@code int} argument.  IEEE 754 distinguishes between two&#10;     * kinds of NaNs, quiet NaNs and &lt;i&gt;signaling NaNs&lt;/i&gt;.  The&#10;     * differences between the two kinds of NaN are generally not&#10;     * visible in Java.  Arithmetic operations on signaling NaNs turn&#10;     * them into quiet NaNs with a different, but often similar, bit&#10;     * pattern.  However, on some processors merely copying a&#10;     * signaling NaN also performs that conversion.  In particular,&#10;     * copying a signaling NaN to return it to the calling method may&#10;     * perform this conversion.  So {@code intBitsToFloat} may&#10;     * not be able to return a {@code float} with a signaling NaN&#10;     * bit pattern.  Consequently, for some {@code int} values,&#10;     * {@code floatToRawIntBits(intBitsToFloat(start))} may&#10;     * &lt;i&gt;not&lt;/i&gt; equal {@code start}.  Moreover, which&#10;     * particular bit patterns represent signaling NaNs is platform&#10;     * dependent; although all NaN bit patterns, quiet or signaling,&#10;     * must be in the NaN range identified above.&#10;     *&#10;     * @param   bits   an integer.&#10;     * @return  the {@code float} floating-point value with the same bit&#10;     *          pattern.&#10;     */" />
      <item value="/**&#10;     * Parses the string argument as an unsigned integer in the radix&#10;     * specified by the second argument.  An unsigned integer maps the&#10;     * values usually associated with negative numbers to positive&#10;     * numbers larger than {@code MAX_VALUE}.&#10;     *&#10;     * The characters in the string must all be digits of the&#10;     * specified radix (as determined by whether {@link&#10;     * java.lang.Character#digit(char, int)} returns a nonnegative&#10;     * value), except that the first character may be an ASCII plus&#10;     * sign {@code '+'} ({@code '\u005Cu002B'}). The resulting&#10;     * integer value is returned.&#10;     *&#10;     * &lt;p&gt;An exception of type {@code NumberFormatException} is&#10;     * thrown if any of the following situations occurs:&#10;     * &lt;ul&gt;&#10;     * &lt;li&gt;The first argument is {@code null} or is a string of&#10;     * length zero.&#10;     *&#10;     * &lt;li&gt;The radix is either smaller than&#10;     * {@link java.lang.Character#MIN_RADIX} or&#10;     * larger than {@link java.lang.Character#MAX_RADIX}.&#10;     *&#10;     * &lt;li&gt;Any character of the string is not a digit of the specified&#10;     * radix, except that the first character may be a plus sign&#10;     * {@code '+'} ({@code '\u005Cu002B'}) provided that the&#10;     * string is longer than length 1.&#10;     *&#10;     * &lt;li&gt;The value represented by the string is larger than the&#10;     * largest unsigned {@code int}, 2&lt;sup&gt;32&lt;/sup&gt;-1.&#10;     *&#10;     * &lt;/ul&gt;&#10;     *&#10;     *&#10;     * @param      s   the {@code String} containing the unsigned integer&#10;     *                  representation to be parsed&#10;     * @param      radix   the radix to be used while parsing {@code s}.&#10;     * @return     the integer represented by the string argument in the&#10;     *             specified radix.&#10;     * @throws     NumberFormatException if the {@code String}&#10;     *             does not contain a parsable {@code int}.&#10;     * @since 1.8&#10;     */" />
      <item value="相对" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="360" />
        <entry key="ENGLISH" value="360" />
        <entry key="POLISH" value="1" />
        <entry key="FRENCH" value="2" />
        <entry key="FILIPINO" value="1" />
        <entry key="JAPANESE" value="1" />
        <entry key="SWEDISH" value="1" />
        <entry key="HINDI" value="3" />
        <entry key="INDONESIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1637377973731" />
  </component>
  <component name="Settings">
    <option name="foldOriginal" value="true" />
    <option name="keepFormat" value="true" />
    <option name="overrideFont" value="true" />
    <option name="phoneticFontFamily" value="Segoe UI" />
    <option name="primaryFontFamily" value="Microsoft YaHei UI" />
    <option name="translator" value="YOUDAO" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="6787a6ce50600ef8" />
      </youdao-translate>
    </option>
  </component>
</application>